package generator

import (
	"context"
	"fmt"
	"html/template"
	"log/slog"
	"os"
	"path/filepath"
	"strings"

	"github.com/a-h/templ/cmd/templ/fmtcmd"
	"github.com/a-h/templ/cmd/templ/generatecmd"
	"github.com/a-h/templ/cmd/templ/sloghandler"
	"github.com/nokacper24/static-templ/internal/finder"
)

// Template for the output Go script used for rendering into HTML files.
const outputScript = `// Code generated by STATIC TEMPL; DO NOT EDIT.
package main

import (
	"context"
	"log"
	"os"
	"path/filepath"

	"github.com/a-h/templ"
	{{- range .Imports }}
	"{{ . }}"
	{{- end }}
)

func main() {
	components := []componentToGenerate{
	{{- range .FilesToGenerate }}
		{
			{{ .PackageName }}.{{ .FuncToCall }}(),
			"{{.FilePath}}",
		},
	{{- end }}
	}

	ctx := context.Background()

	for _, comp := range components {
		if err := os.MkdirAll(filepath.Dir(comp.path), os.ModePerm); err != nil {
			log.Fatal("error creating dirs:", err)
		}

		file, err := os.Create(comp.path)
		if err != nil {
			log.Fatal("error creating file:", err)
		}
		defer file.Close()
		if err = comp.component.Render(ctx, file); err != nil {
			log.Fatal("error rendering templ:", err)
		}
	}
}

type componentToGenerate struct {
	component templ.Component
	path      string
}
`

// InputData holds the data required by the output script template.
type InputData struct {
	Imports         []string
	FilesToGenerate []StringedData
}

// StringedData represents the necessary information for generating an HTML file from a templ function.
type StringedData struct {
	FuncToCall  string
	FilePath    string
	PackageName string
}

// Logger for templ commands.
var logger = slog.New(sloghandler.NewHandler(os.Stderr, nil))

// GenerateForBundleMode creates an output script when mode=bundle, transforming templ files to HTML.
func GenerateForBundleMode(outputScriptPath string, imports []string, funcs []finder.FunctionToCall, inputDir string, outputDir string) error {
	pathFunc := func(f finder.FunctionToCall) string {
		normalizedPath := strings.ReplaceAll(filepath.Dir(f.FilePath), "\\", "/")
		return newFilePath(normalizedPath, inputDir, outputDir, f.HtmlFileName())
	}
	return generateFiles(outputScriptPath, "outputPages", outputScript, imports, funcs, pathFunc)
}

// GenerateForInlineMode creates an output script when mode=inline, transforming templ files to HTML in their respective directories.
func GenerateForInlineMode(outputScriptPath string, imports []string, funcs []finder.FunctionToCall, outputPath string) error {
	pathFunc := func(f finder.FunctionToCall) string {
		normalizedPath := strings.ReplaceAll(filepath.Dir(f.FilePath), "\\", "/")
		return strings.Join([]string{normalizedPath, f.HtmlFileName()}, "/")
	}
	return generateFiles(outputScriptPath, "outputComponents", outputScript, imports, funcs, pathFunc)
}

// RunTemplFmt runs the templ fmt command to format templ files.
func RunTemplFmt(files []string, done chan<- struct{}) error {
	args := fmtcmd.Arguments{
		Files: files,
	}
	err := fmtcmd.Run(logger, os.Stdin, os.Stdout, args)
	done <- struct{}{}
	return err
}

// RunTemplGenerate runs the templ generate command to generate Go code from templ files.
func RunTemplGenerate(done chan<- struct{}) error {
	args := generatecmd.Arguments{
		Path: ".",
	}
	ctx := context.Background()
	err := generatecmd.Run(ctx, logger, args)
	done <- struct{}{}
	return err
}

// generateFiles handles the common logic for generating scripts for both pages and components.
func generateFiles(outputScriptPath, templateName, scriptTemplate string, imports []string, funcs []finder.FunctionToCall, pathFunc func(finder.FunctionToCall) string) error {
	tmpl, err := template.New(templateName).Parse(scriptTemplate)
	if err != nil {
		return err
	}

	var stringed []StringedData
	for _, f := range funcs {
		stringed = append(stringed, StringedData{
			FuncToCall:  f.FunctionName,
			FilePath:    pathFunc(f),
			PackageName: f.PackageName,
		})
	}

	data := InputData{
		Imports:         imports,
		FilesToGenerate: stringed,
	}

	file, err := os.Create(outputScriptPath)
	if err != nil {
		return err
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		return err
	}

	return nil
}

// Constructs a new filepath, mirroring the original location.
// Replaces the old dir prefix (input directory path) with new prefix (output directory path),
// and adds the filename at the end.
func newFilePath(originalDirPath string, oldPrefix string, newPrefix string, filename string) string {
	return fmt.Sprint(
		strings.Replace(originalDirPath, oldPrefix, newPrefix, 1),
		"/",
		filename)
}
